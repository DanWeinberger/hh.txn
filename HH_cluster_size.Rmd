---
title: "Household_cluster_size"
author: "Dan Weinberger"
date: "3/3/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(abind)
```


## Some issues
1) We don't know the date of infection; only the date when a person is tested
2) Vaccine could prevent symptoms but not infection, so unvaccinated HH member might get tested first (incorrectly appearing as index)
3) As time goes on and more people are vaccinated, te index cases are more likely to be younger and might not be comparable to index cases from earlier in study
4) Decision to get tested could be influenced by vaccination
5) Decision to get tested is influenced by presence of an infected HH member
6) If people were infected/positive earlier in epidemic, need to exclude them as susceptibles

Longini paper: https://academic.oup.com/aje/article/115/5/736/153401?login=true
"A great deal of information concerning community transmission is contained in the comparison between households that had no infections and those experiencing at least one infection."

*B* as the probability that a susceptible household member escapes being infected from the community during the period of observation

*Q* as the probability a household member escapes infectious contact from a single infected household member during his entire infectious period

the probability that **j** of **k** initial susceptibles become infected in a particular household during the period of observation can be found.

m_jk gives probability that j of k susceptibles become infected

```{r}

#Columns=HH size; rows=N infected 0:7)
#This data isn't quite right--don't have any HH of size 1 (smallest is size 2)
# ds <- t(matrix(c(340,197,84,60,25,11,3,2,1,0,
#                  164,104,60,29,15,6,4,2,0,0,
#                  0,57,57,25,9,4,0,3,0,1,
#                  0,0,27,11,10,3,3,3,0,0,
#                  0,0,0,7,1,0,2,0,0,0,
#                  0,0,0,0,1,1,3,0,0,0,
#                  rep(0,6),1,1,0,0,rep(0,40)),
#                ncol=11))

#Data from longini
ds <- t(matrix(c(40,63,18,17,3,
               4,12,10,5,4,
               0,2,3,3,2,
               0,0,2,3,2,
               0,0,0,1,1,
               0,0,0,0,0), nrow=5 ))

# #Number of kids in each cell, rather than N of households
# dsN <- matrix(NA, nrow=nrow(ds), ncol=ncol(ds))
# for(i in 1: ncol(ds)){
#   dsN[,i] <- ds[,i] *i
# }

max.hh.size <- ncol(ds)

choose_kj_mat <- matrix(0, nrow=max.hh.size, ncol=max.hh.size)
for(k in 2: max.hh.size){
  for(j in 1:k){
    choose_kj_mat[k,j] <- choose(k,j)
  }
}

```


```{r}
source('./R/longini_jags.R')
```

```{r}
##############################################################
#Model Fitting
##############################################################
inits1=list(".RNG.seed"=c(123), ".RNG.name"='base::Wichmann-Hill')
inits2=list(".RNG.seed"=c(456), ".RNG.name"='base::Wichmann-Hill')
inits3=list(".RNG.seed"=c(789), ".RNG.name"='base::Wichmann-Hill')


##############################################
#Model Organization
##############################################
model_spec<-textConnection(longini_jags)
model_jags<-jags.model(model_spec, 
                       inits=list(inits1,inits2, inits3),
                       data=list( 
                                 'ds'=ds,
                                 'max.hh.size'=ncol(ds),
                                 'n.hh'= apply(ds,2,sum),
                                 'choose_kj_mat'=choose_kj_mat
                                 ),
                       n.adapt=10000, 
                       n.chains=3)

```

```{r}
params<-c('B','Q')

##############################################
#Posterior Sampling
##############################################
posterior_samples<-coda.samples(model_jags, 
                                params, 
                                n.iter=10000)
posterior_samples.all<-do.call(rbind,posterior_samples)

post_median<-apply(posterior_samples.all, 2, median)
sample.labs<-names(post_median)
ci<-t(hdi(posterior_samples.all, credMass = 0.95))
ci <- cbind(post_median,ci)
row.names(ci)<-sample.labs
names(post_median)<-sample.labs

B.index <- grep('B',sample.labs)
Q.index <- grep('Q',sample.labs)

CPI.mcmc <- 1- ci[B.index,]
SAR.mcmc <- 1-ci[Q.index,]




```


LL approach
```{r}
source(file="./R/longiniLL.R")
```

Find opitimal values of B and Q by minimizing the negative log-likelihood
```{r}
BQest <- optim(c(0.9,0.5),longiniLL,data=ds)$par
```

What is the estimated community probability of infection (CPI) and 
    secondary attack rate (SAR)?

```{r}
CPI.ll <- 1 - BQest[1]
SAR.ll <- 1 - BQest[2]
```

Compare MCMC and LL approaches
Agrees well with the original estimates for SAR and CPI from the Longini paper
```{r}
#In original paper Q_hat=0.853; B_Hat=0.868

CPI.ll
CPI.mcmc
1- 0.868

SAR.ll
SAR.mcmc
1-0.853

```

## Covariates

stratify by whether they have children

```{r}
source('./R/longini_jags_covariates.R')
```

```{r}
#Generate dataset--super dumb way to do it--have N infected HH in ds2 half of those in ds1--to do this right need a simulation

# ds2 <- t(matrix(
#   c(rpois(length(ds[1,]), lambda=ds[1,] ),
#     rpois(length(ds[-1,]), lambda=(ds[-1,]*0.5) ))
#     , nrow=ncol(ds)
#     ))

#Table 6; hh w children
ds1 <- t(matrix(c( 0, 0, 17,15,3,
          0, 0, 8,5,4, 
          0,0,3,3,2,
          0,0,2,3,2,
          0,0,0,1,1,
          0,0,0,0,0
          ),nrow=5))
ds2 <- t(matrix(c(40,61,0,0,0,
         4,11,0,0,0,
         0,1,0,0,0,
         rep(0,5*3)),
          nrow=5)
         )
         
         

ds.vax.array <- abind(ds1,ds2, along=3)


```


```{r}
##############################################################
#Model Fitting
##############################################################
inits1=list(".RNG.seed"=c(1234), ".RNG.name"='base::Wichmann-Hill')
inits2=list(".RNG.seed"=c(4567), ".RNG.name"='base::Wichmann-Hill')
inits3=list(".RNG.seed"=c(6789), ".RNG.name"='base::Wichmann-Hill')


##############################################
#Model Organization
##############################################
model_spec<-textConnection(longini_jags_covar)
model_jags_covar<-jags.model(model_spec, 
                       inits=list(inits1,inits2, inits3),
                       data=list( 
                                 'ds'=ds.vax.array,
                                 'max.hh.size'=dim(ds.vax.array)[2],
                                 'n.hh'= apply(ds.vax.array,c(2,3),sum),
                                 'choose_kj_mat'=choose_kj_mat
                                 ),
                       n.adapt=10000, 
                       n.chains=3)

```
```{r}
params<-c('B','Q', 'beta1','delta1','alpha1','alpha2')

##############################################
#Posterior Sampling
##############################################
posterior_samples_covar<-coda.samples(model_jags_covar, 
                                params, 
                                n.iter=10000)
posterior_samples.covar.all<-do.call(rbind,posterior_samples_covar)

post_median<-apply(posterior_samples.covar.all, 2, median)
sample.labs<-names(post_median)
ci<-t(hdi(posterior_samples.covar.all, credMass = 0.95))
ci <- cbind(post_median,ci)
row.names(ci)<-sample.labs
names(post_median)<-sample.labs

B1.index <- grep('B[1]',sample.labs, fixed=T)
B2.index <- grep('B[2]',sample.labs, fixed=T)

Q1.index <- grep('Q[1]',sample.labs, fixed=T)
Q2.index <- grep('Q[2]',sample.labs, fixed=T)

beta1.index <- grep('beta1', sample.labs, fixed=T)

CPI1.mcmc <- 1- ci[B1.index,]
CPI2.mcmc <- 1- ci[B2.index,]

SAR1.mcmc <- 1-ci[Q1.index,]
SAR2.mcmc <- 1-ci[Q2.index,]

beta1.mcmc <- 1-ci[beta1.index,]

CPI.mcmc
SAR.mcmc

#Ratio of CPI for HH with and without kids 
CPI1.samples <- 1 - posterior_samples.covar.all[,B1.index]
CPI2.samples <- 1 - posterior_samples.covar.all[,B2.index]
#CPI.log.ratio.samples <- log(CPI1.samples / CPI2.samples)
CPI.ratio.samples <- CPI1.samples / CPI2.samples

##Equal tailed interval ives same result if use log or original scale
quantile(CPI.ratio.samples, probs=c(0.025,0.5,0.975))
#exp(quantile(CPI.log.ratio.samples, probs=c(0.025,0.5,0.975)) )

#CPI.ratio.hdi_log_exp <-  exp(c(median(CPI.log.ratio.samples), t(hdi(CPI.log.ratio.samples, credMass = 0.95))))

CPI.ratio.hdi <-  c(median(CPI.ratio.samples), t(hdi(CPI.ratio.samples, credMass = 0.95)))

CPI.ratio.hdi ##This is the one suggested by Josh
#CPI.ratio.hdi_log_exp

#Ratio of SAR for HH with and without kids 
SAR1.samples <- 1 - posterior_samples.covar.all[,Q1.index]
SAR2.samples <- 1 - posterior_samples.covar.all[,Q2.index] 
SAR.ratio.samples <- log(SAR1.samples / SAR2.samples)
SAR.ratio.hdi <-  exp(c(median(SAR.ratio.samples), t(hdi(SAR.ratio.samples, credMass = 0.95))))
SAR.ratio.hdi

```


